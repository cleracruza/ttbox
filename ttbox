#!/usr/bin/env python

import yaml
import argparse
import sys
from struct import pack, unpack


def error(msg):
    sys.stderr.write("%s\n" % (msg))
    sys.exit(1)


def parse_arguments():
    parser = argparse.ArgumentParser(
        description='Toolbox for GME and tttool yaml files')

    subparsers = parser.add_subparsers(title='Commands',
                                       description='Available commands')

    for command_cls in COMMAND_CLASSES:
        command = command_cls()
        command.register_subparser(subparsers)

    return parser.parse_args()


class BaseCommand(object):
    def __init__(self):
        pass

    def configure(self, config, args):
        pass

    def get_subparser_short_help(self):
        raise NotImplementedError(
            'Please implement this fuction in your subclass')

    def register_subparser(self, subparsers):
        command_name = self.__class__.__name__
        if command_name.endswith('Command'):
            command_name = command_name[0:-7]
        command_name = ''.join([
                (letter if letter.islower() else ('-' + letter))
                for letter in command_name])[1:]
        command_name = command_name.lower()

        parser = subparsers.add_parser(command_name,
                                       help=self.get_subparser_short_help())

        parser.set_defaults(command=self)

        return parser

    def __str__(self):
        raise NotImplementedError(
            'Please implement this fuction in your subclass')

    def run(self):
        raise NotImplementedError(
            'Please implement this fuction in your subclass')


class YamlCommand(BaseCommand):
    def configure(self, config, args):
        self.YAML_FILE = args.YAML_FILE
        self.yaml = self.getYaml(self.YAML_FILE)

    def register_subparser(self, subparsers):
        parser = super(YamlCommand, self).register_subparser(
            subparsers)

        parser.add_argument('YAML_FILE',
                            help='YAML file to parse')

        return parser

    def getYaml(self, yaml_file):
        with open(yaml_file, 'r') as stream:
            try:
                return yaml.load(stream)
            except yaml.YAMLError as exc:
                error(str(exc))


class GmeRawChunk(object):
    def __init__(self, offset, buffer):
        self.offset = offset
        self.buffer = buffer

    def kind_to_cls(self, kind):
        name = 'Gme' + kind[0].upper() + kind[1:] + 'Chunk'
        return getattr(sys.modules[__name__], name)

    def setInt32(self, offset, value):
        self.buffer = self.buffer[0:offset] + pack('<I', value) \
            + self.buffer[offset+4:]

    def checksum(self):
        ret = 0
        for b in self.buffer:
            ret += ord(b)
        return ret & 0xffffffff

    def write(self, f):
        f.write(self.buffer)

    def split(self, head_kind, offset, tail_kind):
        head_cls = self.kind_to_cls(head_kind)
        tail_cls = self.kind_to_cls(tail_kind)
        if (offset < len(self.buffer)):
            offset += len(self.buffer)
        head = head_cls(0, self.buffer[0:offset])
        tail = tail_cls(offset, self.buffer[offset:])
        return (head, tail)

    def __str__(self):
        return "%s(offset: %d, len: %d)" % (self.__class__.__name__,
                                            self.offset, len(self.buffer))


class GmeChecksumChunk(GmeRawChunk):
    def __str__(self):
        ret = super(GmeChecksumChunk, self).__str__()
        ret += "(checksum: %s)" % (unpack('<I', self.buffer))
        return ret


class GmeFile(object):
    def __init__(self, file_name):
        self.file_name = file_name
        with open(self.file_name, 'rb') as f:
            buffer = f.read()
        full = GmeRawChunk(0, buffer)

        (full_no_checksum, checksum) = full.split('raw', -4, 'checksum')

        self.chunks = [full_no_checksum, checksum]

    def set_product_id(self, product_id):
        header = self.chunks[0]
        header.setInt32(0x14, product_id)

    def checksum(self):
        ret = 0
        for chunk in self.chunks[:-1]:
            ret += chunk.checksum()
        return ret & 0xffffffff

    def write(self, file_name):
        with open(file_name, 'wb') as f:
            for chunk in self.chunks[:-1]:
                chunk.write(f)
            f.write(pack('<I', self.checksum()))


class GmeCommand(BaseCommand):
    def configure(self, config, args):
        self.GME_FILE = args.GME_FILE
        self.gme = self.getGme(self.GME_FILE)

    def register_subparser(self, subparsers):
        parser = super(GmeCommand, self).register_subparser(
            subparsers)

        parser.add_argument('GME_FILE',
                            help='GME file to parse')

        return parser

    def getGme(self, gme_file):
        return GmeFile(gme_file)


class SetProductId(GmeCommand):
    def get_subparser_short_help(self):
        return 'sets the product id of a GME file'

    def configure(self, config, args):
        super(SetProductId, self).configure(config, args)
        self.product_id = args.PRODUCT_ID

    def register_subparser(self, subparsers):
        parser = super(SetProductId, self).register_subparser(
            subparsers)

        parser.add_argument('PRODUCT_ID',
                            type=int,
                            help='The product id to set')

    def run(self):
        self.gme.set_product_id(self.product_id)
        self.gme.write(self.GME_FILE)


class DumpOids(YamlCommand):
    def get_subparser_short_help(self):
        return 'prints the oids of a YAML file'

    def run(self):
        oids = sorted(self.yaml.get('scripts', {}).keys() + ['START'])
        print("\n".join(oids))


class DumpProductId(YamlCommand):
    def get_subparser_short_help(self):
        return 'prints the product id of a YAML file'

    def run(self):
        print(self.yaml.get('product-id', None))


COMMAND_CLASSES = [
    SetProductId,
    DumpOids,
    DumpProductId,
]


if __name__ == '__main__':
    args = parse_arguments()

    config = {}

    command = args.command
    command.configure(config, args)
    command.run()
